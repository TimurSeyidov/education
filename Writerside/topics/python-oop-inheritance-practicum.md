# Задачи

## Задача 1 {id="1_1"}

В игре **Minecraft** все игровые объекты делятся на три типа: **блоки**, **сущности** и **предметы**.
**Блоки** – это «кирпичики», из которых состоит весь игровой мир.
**Сущности** – это все динамические и движущиеся игровые объекты.
**Предметы** – это все остальные объекты.
Реализуйте иерархию классов для игры **Minecraft**:
- `BaseObject` – базовый класс для всех объектов. Интерфейс этого класса состоит из двух методов:
  1. `__init__(x, y, z)` – конструктор класса, который принимает на вход 3 числа (координаты объекта в игровом мире)
  2. `get_coordinates()` – метод, возвращающий список координат `x`, `y`, `z` (именно в таком порядке)
- `Block` – класс, наследующийся от `BaseObject`. У этого класса есть дополнительный метод `shatter()`, который ничего не принимает на вход и ничего не возвращает. При вызове этого метода все три координаты объекта `Block` должны стать равны `None`.
- `Entity` – класс, наследующийся от `BaseObject`. У этого класса есть дополнительный метод `move(x, y, z)`, который принимает на вход 3 числа (новые координаты объекта) и ничего не возвращает. При вызове этого метода координаты объекта должны стать равны `x`, `y`, `z` соответственно.
- `Thing` – класс, наследующийся от `BaseObject`. У этого класса нет дополнительных методов.

## Задача 2 {id="1_2"}

Рассмотрим следующую упрощенную классификацию живых существ:
- Живые существа делятся на бесклеточных (к ним относятся вирусы) и клеточных.
- Клеточные в свою очередь делятся на прокариотов (их клетки не содержат ядер; к прокариотам относятся бактерии) и эукариотов (их клетки имеют ядра).
- Эукариоты – одноклеточные, грибы, растения и животные.
Постройте иерархию классов для данной классификации.
Для именования классов используйте латинские названия:
- Бесклеточные: `Acellularia`
- Клеточные: `Cellularia`
- Прокариоты: `Prokaryota`
- Эукариоты: `Eukaryota`
- Одноклеточные: `Unicellularia`
- Грибы: `Fungi`
- Растения: `Plantae`
- Животные: `Animalia`

## Задача 3 {id="1_3"}

Разобьём пользователей интернет-обучения на три группы: **администраторы**, **преподаватели** и **ученики**.
Все пользователи могут решать задачи.
Также администраторы могут редактировать задачи, а преподаватели могут проверять решения учеников.
Также среди администраторов есть особенные «супер-администраторы», которые могут сделать администратором любого пользователя портала.
Реализуйте следующую иерархию классов:
- `User` – базовый класс с методом `solve(n)`, где `n` – целое число (идентификатор задачи).
- `Student` – класс, наследующийся от `User`.
- `Teacher` – класс, наследующийся от `User` и имеющий дополнительный метод `check_solution(user, n)`, где `user` – объект типа `User`, а `n` – целое число (идентификатор задачи).
- `Admin` – класс, наследующийся от `User` и имеющий дополнительный метод `edit(n)`, где `n` – целое число (идентификатор задачи).
- `SuperAdmin` – класс, наследующийся от `Admin` и имеющий дополнительный метод `grant(user)`, где `user` – объект типа `User`.

Сами методы `solve`, `check_solution`, `edit` и `grant` реализовывать не нужно. То есть, например, для метода `solve` достаточно написать

```python
def solve(self, n):
    pass
```

## Задача 4 {id="1_4"}

В социальной сети есть два вида пользователей: **люди** и **сообщества**.
Все пользователи должны указывать свое имя.
Люди могут также указывать свою дату рождения, а сообщества – своё краткое описание.
Все пользователи (и люди, и сообщества) могут отправлять сообщения друг другу, а также выкладывать посты на своей стене.
Люди могут подписываться на других людей и на сообщества.
Реализуйте иерархию классов в соответствии с этим описанием.
- `User` – базовый класс. Его конструктор должен принимать один аргумент – имя. Также этот класс должен предоставлять методы
  - `send_message(user, message) `– отправить сообщение message пользователю `user`
  - `post(message)` – отправить сообщение `message` себе на стену
  - `info()` – вернуть строку с дополнительной информацией о пользователе. Для класса `User` это пустая строка, метод `info()` будет переопределяться в производных классах
  - `describe()` – напечатать имя пользователя и дополнительную информацию о нем (т.е. результат работы метода `info()`)
- `Person` – производный от класса `User`. Его конструктор должен принимать на вход два аргумента – имя и дату рождения. Метод `info()` класса `Person` должен возвращать строку вида «**Дата рождения: ...**» Также у `Person` должен быть реализован дополнительный метод `subscribe(user)`, где `user` – объект класса `User`.
- `Community` – производный от класса `User`. Его конструктор должен принимать на вход два аргумента – имя и краткое описание. Метод `info()` класса `Community` должен возвращать строку вида «**Описание: ...**»

## Задача 5 {id="1_5"}

Все животные обладают некоторыми общими свойствами; в частности, они дышат кислородом и чем-то питаются.
К животным относятся рыбы, которые умеют плавать, и птицы, которые откладывают яйца.
Большинство птиц (но не все!) также умеют летать.
Реализуйте следующую иерархию классов:
- `Animal` – базовый класс с методами `breathe()` и `eat()`
- `Fish` – наследник класса `Animal` с дополнительным методом `swim()`
- `Bird` – наследник класса `Animal` с дополнительным методом `lay_eggs()`
- `FlyingBird` – наследник класса `Bird` с дополнительным методом `fly()`
Сами методы `breathe`, `eat`, `swim`, `lay_eggs` и `fly` реализовывать не нужно. То есть, например, для метода `breathe` достаточно написать

```python
def breathe(self):
    pass
```

## Задача 6 {id="1_6"}

Реализуйте иерархию транспортных средств.
За основу можно взять такую:
- Водный транспорт.
- Воздушный транспорт. Можно поделить на авиацию (самолёты) и воздухоплавание (дирижабли и воздушные шары).
- Наземный транспорт. Делится на железнодорожный, автомобильный, велосипедный и движимый животными.
- Космический транспорт &#128522;

Постарайтесь реализовать иерархию максимально подробно, дополните предложенный вариант своими классами.
Имена классов выберите самостоятельно.

## Задача 7 {id="1_7"}

С помощью наследования постройте иерархию геометрических фигур, состоящую из следующих классов:
- `Shape` (Фигура)
- `Polygon` (Многоугольник)
- `Triangle` (Треугольник)
- `IsoscelesTriangle` (Равнобедренный треугольник)
- `EquilateralTriangle` (Равносторонний треугольник)
- `Quadrilateral` (Четырехугольник)
- `Parallelogram` (Параллелограмм)
- `Rectangle` (Прямоугольник)
- `Square` (Квадрат)
Иерархия должна быть построена в соответствии со следующим условием: класс `B` должен наследоваться от класса `A`, если `B` является частным случаем `A`.
Сами классы реализовывать не нужно.

## Задача 8 {id="1_8"}

Реализуйте несколько классов, вычисляющих суммы следующих последовательностей натуральных чисел от 1 до N:

```tex
\begin{multline}
    \begin{split}
        1 + 2^2 + 3^2 + ... + N^2 \\
        1 + 2 + 3 + ... + N \\
        1 + 2^3 + 3^3 + ... + N^3
    \end{split}
\end{multline}
```

Сделайте это с помощью наследования.
Базовым классом будет `Summator`, который реализует методы `transform(n)` и `sum(N)`.
- Метод `transform(n)` выполняет преобразование элемента последовательности. Для класса `Summator` это будет тождественное преобразование, т.е. `transform(n) == n`. Метод `transform(n)` будет переопределяться в производных классах.
- Метод `sum(N)` должен вычислять сумму значений `transform(n)` для всех значений `n` от 1 до N.
Производные классы должны переопределять метод `transform(n)`:
- `SquareSummator`: `transform(n) == n ** 2`
- `CubeSummator`: `transform(n) == n ** 3`
Метод `sum(N)` переопределять не нужно.

> **Подсказка**: для проверки корректности реализации классов `Summator`, `SquareSummator`, `CubeSummator` воспользуйтесь формулами:
```tex
\begin{multline}
    \begin{split}
        1 + 2 + ... + N = \frac{N(N + 1)}{2}\\
        1 + 2^2 + ... + N^2 = \frac{N(N + 1)(N + 1)}{6}\\
        1 + 2^3 + ... + N^3 = \frac{N(N + 1)}{2})^2
    \end{split}
\end{multline}
```

## Задача 9 {id="1_9"}

На сайте поиска вакансий есть два типа объектов: вакансии и резюме.
Каждый такой объект имеет название профессии (в вакансии – предлагаемая профессия, в резюме – желаемая профессия).
Также в вакансиях указывается название компании и предлагаемая зарплата, а в резюме – стаж работы.
Реализуйте иерархию классов для такого сайта.
- `Profile` – базовый класс. Его конструктор должен принимать один аргумент – название профессии. Также этот класс должен представлять методы
  - `info()`, который должен возвращать строку с дополнительной информацией. Для класса `Profile` эта строка должна быть пустой, в производных классах этот метод будет переопределяться.
  - `describe()`, который печатает название и дополнительную информацию (т.е. результат работы метода `info()`)
- `Vacancy` – наследник класса `Profile`. Его конструктор должен принимать два аргумента – название профессии и предлагаемую зарплату. При написании конструктора используйте конструктор базового класса. `Метод info()` класса `Vacancy` должен возвращать строку вида **«Предлагаемая зарплата: ...»**
- `Resume` – наследник класса `Profile`. Его конструктор должен принимать два аргумента – название профессии и стаж работы. При написании конструктора используйте конструктор базового класса. Метод `info()` класса `Resume` должен возвращать строку вида **«Стаж работы: ...»**

## Задача 10 {id="1_10"}

Создайте класс `Triangle`, представляющий треугольник.
Конструктор этого класса должен принимать на вход 3 числа (длины сторон треугольника).
Также у этого класса должен быть метод `perimeter()`, возвращающий периметр.
Отнаследуйте от класса `Triangle` класс `EquilateralTriangle`, представляющий равносторонний треугольник.
Переопределите конструктор этого класса с использованием конструктора базового класса.
Конструктор класса `EquilateralTriangle` должен принимать на вход 1 число (длину стороны).

## Задача 11 {id="1_11"}

Реализуйте класс `PowerSummator`, вычисляющий сумму последовательности натуральных чисел от 1 до N:


```tex
\begin{equation}
1 + 2^b + 3^b + ... + N^b
\end{equation}
```

где **b** – произвольное вещественное число.
Как и в задаче 8, класс `PowerSummator` должен наследоваться от класса `Summator`.
Напомним, что класс `Summator` должен иметь методы `transform(n)` и `sum(N)`.
- Метод `transform(n)` выполняет преобразование элемента последовательности. Для класса `Summator` это будет тождественное преобразование, т.е. `transform(n) == n`. Метод `transform(n)` должен быть переопределен в классе `PowerSummator`.
- Метод `sum(N)` должен вычислять сумму значений `transform(n)` для всех значений n от 1 до N.
Помимо метода `transform`, для класса `PowerSummator` также нужно переопределить конструктор. Конструктор класса `PowerSummator` должен принимать один параметр – степень `b`, в которую нужно возводить элементы последовательности.
Также отнаследуйте от класса `PowerSummator` классы `SquareSummator` и `CubeSummator`, которые (как и в классной задаче 8) должны вычислять суммы квадратов и кубов соответственно. Конструкторы классов `SquareSummator` и `CubeSummator` не должны принимать аргументов. В классах `SquareSummator` и `CubeSummator` должен быть переопределён только конструктор; переопределять другие методы нельзя.

## Задача 12 {id="1_12"}

Создайте класс `A`, в котором определены:
- метод приведения к строке, возвращающий `A.__str__ method`
- метод `hello()`, выводящий на экран строку `Hello`
Создайте класс `B`, в котором определены:
- метод приведения к строке, возвращающий `B.__str__ method`
- метод `good_evening()`, выводящий на экран строку `Good evening`
Создайте класс `C`, унаследованный от `A` и `B`, который при приведении к строке использует метод класса `A` (сам класс `C` не должен содержать методов `__str__` или `__repr__`).
Создайте класс `D`, унаследованный от `A` и `B`, который при приведении к строке использует метод класса `B` (сам класс `D` не должен содержать методов `__str__` или `__repr__`).

### Пример 1 {id="1_12_1"}

**Ввод**

```python
# Ваш код

c = C()
c.hello()
c.good_evening()
d = D()
d.hello()
d.good_evening()
print(c)
print(d)
```

**Вывод**
```python
Hello
Good evening
Hello
Good evening
A.__str__ method
B.__str__ method

```

### Пример 2 {id="1_12_2"}

**Ввод**

```python
# Ваш код

def new_method(arg):
    return  "new method"

def new_method2(arg):
    return "new method 2"


A.__str__ = new_method
B.__str__ = new_method2
c = C()
c.hello()
c.good_evening()
d = D()
d.hello()
d.good_evening()
print(isinstance(c, A), isinstance(c, B))
print(isinstance(d, A), isinstance(d, B))
print(c)
print(d)
```

**Вывод**
```python
Hello
Good evening
Hello
Good evening
True True
True True
new method
new method 2
```

## Задача 13 {id="1_13"}

При разработке компьтерных игр зачастую создаётся очень сложная система классов. В этой задаче Вам будет необходимо сделать небольшую заготовку, которую потом можно будет использовать для создания своей игры.

Реализуйте класс `Weapon` для оружия, который при инициализации должен принимать:
- имя оружия `name`
- наносимый урон `damage`
- радиус, на котором оружие может достать до врага – `range`.

В классе `Weapon` должны быть реализованы следующие методы:
- `hit(actor, target)` – удар персонажем `actor` персонажа `target`. Метод должен проверять, жив ли персонаж `target`, если нет, то выводить сообщение **«Враг уже повержен»**, иначе должна проводится проверка расстояния от `actor` до `target`. Если расстояние больше `range` оружия, тогда надо выводить сообщение **«Враг слишком далеко для оружия `name`»**. В случае, если `target` жив и оружие имеет достаточный `range`, вывести сообщение **«Врагу нанесен урон оружием `name` в размере `damage`»** и нанести урон `target`.
- приведение к строке – при приведении к строке должно возвращаться имя оружия.

Реализуйте класс `BaseCharacter` для создания базовых персонажей, который при инициализации должен принимать `pos_x` и `pos_y` – позицию персонажа в мире, `hp` – количество жизней персонажа.
Класс `BaseCharacter` должен реализовывать методы:
- `move(delta_x, delta_y)` – для перемещения персонажа на `delta_x` и `delta_y` в игровом мире.
- `is_alive()` – проверка, жив ли персонаж. Возвращает `True`, если жив, иначе – `False`.
- `get_damage(amount)` – убавляет количество жизней персонажа на `amount`. При достижении `0` или отрицательного значения персонаж считается мёртвым.
- `get_coords()` – возвращает кортеж с текущими координатами персонажа.

Реализуйте класс `BaseEnemy` для создания противников, который расширяет класс `BaseCharacter`. При инициализации он должен принимать `pos_x` и `pos_y` – позицию персонажа в мире, `weapon` – оружие, `hp` – количество жизней персонажа. Класс должен использовать инициализатор `BaseCharacter`.
Класс `BaseEnemy` должен реализовывать следующие методы:
- `hit(target)` – для удара персонажа `target`. Метод должен позволять ударить только персонажа класса `MainHero`. Для всех других классов должно печататься сообщение **«Могу ударить только Главного героя»**.
- приведение к строке – при приведении к строке должно возвращаться **«Враг на позиции (`pos_x`, `pos_y`) с оружием `weapon`»**

Реализуйте класс `MainHero` для создания главного героя, который расширяет класс `BaseCharacter`. При инициализации он должен принимать `pos_x` и `pos_y` – позицию персонажа в мире, `name` – имя персонажа, `hp` – количество жизней персонажа. Класс должен использовать инициализатор `BaseCharacter`.
Класс `MainHero` должен реализовывать следующие методы:
- `hit(target)` – для удара персонажа `target`. Метод должен проверять, есть ли у персонажа оружие, если его нет выводить - **«Я безоружен»**, иначе позволять ударить только персонажа класса `BaseEnemy`. Для всех других классов должно печататься сообщение **«Могу ударить только Врага»**.
- `add_weapon(weapon)` – добавляет оружие в инвентарь персонажа, если это оружие единственное, то оно должно экипироваться сразу же. Метод должен печатать: **«Подобрал `weapon`»**. Метод должен работать только для переданных объектов класса `Weapon`, для всего остального он должен печатать сообщение **«Это не оружие»**.
- `next_weapon()` – для смены оружия. Если оружия нет, то должно выводиться **«Я безоружен»**, если есть только одно оружие – **«У меня только одно оружие»**, иначе должна производиться смена оружия на следующее (в порядке подбора, по кругу) и выводиться сообщение **«Сменил оружие на `weapon`»**.
- `heal(amount)` – для повышения количества жизней персонажа на `amount`. При этом максимальный уровень здоровья главного героя – `200`. Также должно выводиться сообщение **«Полечился, теперь здоровья `hp`»**.

### Пример 1 {id="1_13_1"}

**Ввод**

```python
# Ваш код

weapon1 = Weapon("Короткий меч", 5, 1)
weapon2 = Weapon("Длинный меч", 7, 2)
weapon3 = Weapon("Лук", 3, 10)
weapon4 = Weapon("Лазерная орбитальная пушка", 1000, 1000)
princess = BaseCharacter(100, 100, 100)
archer = BaseEnemy(50, 50, weapon3, 100)
armored_swordsman = BaseEnemy(10, 10, weapon2, 500)
archer.hit(armored_swordsman)
armored_swordsman.move(10, 10)
print(armored_swordsman.get_coords())
main_hero = MainHero(0, 0, "Король Артур", 200)
main_hero.hit(armored_swordsman)
main_hero.next_weapon()
main_hero.add_weapon(weapon1)
main_hero.hit(armored_swordsman)
main_hero.add_weapon(weapon4)
main_hero.hit(armored_swordsman)
main_hero.next_weapon()
main_hero.hit(princess)
main_hero.hit(armored_swordsman)
main_hero.hit(armored_swordsman)
```

**Вывод**
```python
Могу ударить только Главного героя
(20, 20)
Я безоружен
Я безоружен
Подобрал Короткий меч
Враг слишком далеко для оружия Короткий меч
Подобрал Лазерная орбитальная пушка
Враг слишком далеко для оружия Короткий меч
Сменил оружие на Лазерная орбитальная пушка
Могу ударить только врага
Врагу нанесен урон оружием Лазерная орбитальная пушка в размере 1000
Враг уже повержен
```

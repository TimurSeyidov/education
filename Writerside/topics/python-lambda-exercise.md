# Задачи

## Задача 1 {id="19_1"}

Напишите функцию `arithmetic_operation(operation)`, которая принимает символ одной из четырех арифметических операций, а возвращает функцию двух аргументов для соответствующей операции.


### Пример {id="19_1_1"}

**Ввод**

```python
operation = arithmetic_operation('+')
print(operation(1, 4))
```

**Вывод**
```bash
5
```

## Задача 2 {id="19_2"}

Напишите свою функцию `simple_map(transformation, values)`, которая из одного списка делает другой. Каждый элемент результирующего списка должен получаться применением функции преобразования `transformation` к соответствующему элементу списка `values`.

> Использовать стандартную функцию `map` **запрещено**

### Пример {id="19_2_1"}

**Ввод**

```python
values = [1, 3, 1, 5, 7]
print(*simple_map(lambda x: x + 5, values))
```

**Вывод**
```bash
6 8 6 10 12
```

## Задача 3 {id="19_3"}

Посчитайте сумму квадратов всех двузначных чисел, делящихся на 9.

При решении задачи используйте комбинацию функций `filter`, `map`, `sum`.

> На 9 должно делиться исходное двузначное число, а не его квадрат.

## Задача 4 {id="19_4"}

У вас есть код, который вы не можете менять (так часто бывает, когда код в глубине программы используется множество раз и вы не хотите ничего сломать):

```python
transformation = <???>
values = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
# или любой другой список 
transformed_values = list(map(transformation, values))
```

Единственный способ вашего взаимодействия с этим кодом – посредством задания функции `transformation`.

Однако вы поняли, что для вашей текущей задачи вам не нужно никак преобразовывать список значений, а нужно получить его как есть.

Напишите такое лямбда-выражение `transformation`, чтобы `transformed_values` получился копией `values`. Переменная `transformation` должна быть глобальной, чтобы проверяющая система смогла его найти. Кроме `transformation` вам ничего писать не нужно. Печатать на экран – тоже.


### Пример 1 {id="19_4_1"}

**Ввод**

```python
values = [1, 23, 42, "asdfg"]
transformed_values = list(map(transformation, values))
if values == transformed_values:
    print('ok')
else:
    print('fail')

```

**Вывод**
```bash
ok
```

## Задача 5 {id="19_5"}

Иногда бывают ситуации, когда вы хотите поручить управление программой функции, а не ориентироваться на результат её выполнения. Этому может быть много причин.

Во-первых, это упрощает код, который пользуется вашей функцией.

Во-вторых, бывают программы, в которых несколько наборов команд выполняется параллельно и независимо друг от друга. Например, когда ваша программа подключается к интернету, это обычно делается параллельно с работой остальной программы, ведь запрос может занять как долю секунды, так и минуты. Так же обычно поступают, когда вычисление занимает очень много времени. Взаимодействие с пользователем тоже может занимать очень много времени по меркам компьютерной программы - секунды на то, чтобы пользователь ввёл текст. Было бы очень неудобно, если бы, пока выполняется запрос, зависла бы вся программа.

Проблема с частями программы, которые выполняются независимо друг от друга – в том, что основная программа не может отследить, когда интернет-запрос завершится, если только не будет постоянно это проверять.

Зато сам запрос точно знает, когда он завершился и может что-то сделать по завершении. Например, показать вам загруженную картинку или обновить ленту сообщений. А иногда – сообщить о том, что произошла ошибка.

Но на результат завершения одного и того же запроса можно реагировать по-разному: иногда не нужно делать ничего, в других случаях – показать результат, в третьих – сохранить результат в файл и так далее.

Значит, программе нужно знать, как реагировать на окончание запроса. Это делается при помощи так называемых **коллбэков** (**callback**), что переводится как обратный звонок. Коллбэком называется специальная функция, которая вызывается, когда ваше вычисление завершилось. Для программы, запустившей запрос или долгое вычисление, коллбэк – это способ сообщить, что надлежит сделать, когда вычисление завершится. Коллбэк обычно передают как аргумент функции запуска вычисления.

Ваша задача – написать функцию `ask_password(login, password, success, failure)`, которая получает логин и пароль пользователя и проверяет их правильность.

Пароль считается правильным, если в нём содержится ровно три английские гласные буквы (гласными считать буквы `a`, `e`, `i`, `o`, `u`, `y`) и ровно такой же набор согласных (все буквы, кроме перечисленных шести), как в логине. Порядок и количество согласных также должно совпадать.

Логин и пароль могут передаваться в любом регистре, однако символы, написанные в разных регистрах, считаются одинаковыми. Не будет ошибкой, если вы все введённые символы логина и пароля, сразу приведете к нижнему регистру.

Пример: для логина “**login**” подойдут пароли “**aaalgn**” и “**luagon**“.

Если пароль правильный, функция должна вызвать коллбэк success, передав ему в качестве аргумента логин. А если пароль был неверный - `failure`, передав ему в качестве аргументов логин и сообщение об ошибке (в таком порядке). Сообщение об ошибке должно быть одним из трёх вариантов:
- “Wrong number of vowels”, если в пароле неверное число гласных;
- “Wrong consonants”, если в пароле набор согласных отличается от набора согласных логина;
- “Everything is wrong”, если оба условия нарушены.

Также напишите функцию `main(login, password)`, которая вызывает написанную функцию ask_password так, чтобы в случае успеха она печатала “`Привет, {логин}!`”, а в случае ошибки – “`Кто-то пытался притвориться пользователем {логин}, но в пароле допустил ошибку: {текст ошибки, большими буквами}.`”.

> При вводе логина и пароля НЕ выводите подсказку для пользователя вида “Введите логин:”, так как это собьет с толку проверяющую систему.


### Пример 1 {id="19_5_1"}

**Ввод**

```python
main("anastasia", "nsyatos")
```

**Вывод**
```bash
Привет, anastasia!
```

### Пример 2 {id="19_5_2"}

**Ввод**

```python
main("eugene", "aanig")
```

**Вывод**
```bash
Кто-то пытался притвориться пользователем eugene, но в пароле допустил
ошибку: WRONG CONSONANTS
```

### Пример 3 {id="19_5_3"}

**Ввод**

```python
ask_password("anastasia", "nsyatos", lambda login: print('super'),
    lambda login, err: print('bad'))

```

**Вывод**
```bash
super
```

## Задача 6 {id="19_6"}

Планеты вращаются вокруг звезд по эллиптическим орбитам. Назовём самой далёкой планетой ту, орбита которой имеет самую большую площадь.

Напишите функцию `find_farthest_orbit(list_of_orbits)`, которая среди списка орбит планет найдет ту, по которой вращается самая далёкая планета. Круговые орбиты не учитывайте: вы знаете, что у вашей звезды таких планет нет, зато искусственные спутники были запущены на круговые орбиты.

Результатом функции должен быть кортеж, содержащий длины полуосей эллипса орбиты самой далёкой планеты.

Каждая орбита представляет из себя кортеж из пары чисел – полуосей её эллипса. Площадь эллипса вычисляется по формуле `S = πab`, где `a` и `b` – длины полуосей эллипса.

При решении задачи используйте списочные выражения.

> Проще всего будет найти эллипс в два шага: сначала вычислить самую большую площадь эллипса, а затем найти и сам эллипс, имеющий такую площадь.

Гарантируется, что самая далёкая планета ровно одна.


### Пример {id="19_6_1"}

**Ввод**

```python
orbits = [(1, 3), (2.5, 10), (7, 2), (6, 6), (4, 3)]
print(*find_farthest_orbit(orbits))
```

**Вывод**
```bash
2.5 10
```

## Задача 7 {id="1_7"}

Напишите функцию `same_by(characteristic, objects)`, которая проверяет, все ли объекты имеют одинаковое значение некоторой характеристики, и возвращает `True`, если это так. Если значение характеристики для разных объектов отличается – то `False`. Для пустого набора объектов, функция должна возвращать `True`. Аргумент `characteristic` – это функция, которая принимает объект и вычисляет его характеристику.




### Пример 1 {id="19_7_1"}

**Ввод**

```python
values = [0, 2, 10, 6]
if same_by(lambda x: x % 2, values):
    print('same')
else:
    print('different')
```

**Вывод**
```bash
same
```

### Пример 2 {id="19_7_2"}

**Ввод**

```python
values = [1, 2, 3, 4]
if same_by(lambda x: x % 2, values):
    print('same')
else:
    print('different')

```

**Вывод**
```bash
different
```

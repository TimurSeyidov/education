# Глава 4. Unicode-текст и байты

## О символах, и не только

Под «символом» мы понимаем символ Unicode, и это лучшее определение на сегодняшний момент. Поэтому отдельными элементами объекта типа `str` в Python 3 являются символы **Unicode** (точно так же обстоит дело с элементами объекта `unicode` в Python 2), – а не просто байты, из которых состоят объекты `str` в Python 2.

Идентификатор символа – его кодовая позиция – это число от 0 до 1 114 111 (по основанию 10), которое в стандарте Unicode записывается шестнадцатеричными цифрами (в количестве от 4 до 6) с префиксом «U+». Например, кодовая позиция буквы A равна U+0041, знака евро – U+20AC, музыкального символа скрипичного ключа – U+1D11E. В версии Unicode 13.0.0 (используемой в Python 3.10.0b4) конкретные символы сопоставлены примерно 13 % допусти- мых кодовых позиций.

Какими именно байтами представляется символ, зависит от используемой кодировки. Кодировкой называется алгоритм преобразования кодовых позиций в последовательности байтов и наоборот. Кодовая позиция буквы A (U+0041) кодируется одним байтом \x41 в кодировке UTF-8 и двумя байтами \x41\x00 в кодировке UTF-16LE. Другой пример: знак евро (U+20AC) преобразуется в три байта в UTF-8 – \xe2\x82\xac, но в UTF-16LE кодируется двумя байтами – \xac\x20.

Преобразование из кодовых позиций в байты называется **кодированием**, преобразование из байтов в кодовые позиции – **декодированием**.

```python
s = 'café'
print(len(s))
b = s.encode('utf8')
print(b)
print(len(b))
print(b.decode('utf8'))
```

```bash
4
b'caf\xc3\xa9'
5
café
```


Тип `str` в Python 3 – это, по существу, не что иное, как переименованный тип `unicode` из Python 2. Но вот тип `bytes` в Python 3 – не просто старый тип `str`, и с ним тесно связан тип `bytearray`.
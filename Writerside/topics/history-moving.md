# Перемещение по истории

Git позволяет не только просматривать историю. Еще мы можем перемещаться по истории, загружая в рабочую директорию состояние кода на момент выполнения любого коммита. В этом уроке мы изучим, как перемещаться по истории с помощью команды ```git checkout```.

Для начала воспользуемся командой ```git log```:

```bash
# Показывает сокращенный вывод
git log --oneline

fc74e2d update README.md
65a8ef7 Revert "remove PEOPLE.md"
5120bea add new content
e6f625c add INFO.md
273f81c remove NEW.md
aa600a4 remove PEOPLE.md
fe9893b add NEW.md
3ce3c02 add PEOPLE.md
3c5d976 add README.md
```

Переключимся на момент, когда был выполнен коммит с сообщением *add INFO.md*. Для этого используем команду ```git checkout <хеш коммита>```:

```bash
git checkout e6f625c

Note: switching to 'e6f625c'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

Or undo this operation with:

  git switch -
```

Выполните команду выше и изучите рабочую директорию. Обратите внимание, что хеш вашего коммита может отличаться. Вы увидите, что пропала часть изменений из-за возврата в прошлое. Сами изменения никуда не делись, и мы снова можем вернуться на последний коммит следующей командой:

```bash
# Позже мы поговорим, что такое main
git checkout main
```

Переключившись в нужный коммит, можно не только изучить содержимое репозитория. Еще мы можем забрать какие-то изменения, которые были удалены, но снова понадобились для работы. Для этого достаточно их скопировать, переключиться на последний коммит и вставить в нужный файл.

## Команда ```git branch```

Переключение по коммитам отражается только на содержимом рабочей директории. Больше нигде не видно, где мы находимся. Из-за этого немало программистов забывают, где они находятся. Они начинают работать и очень удивляются, когда не получается выполнить коммит.

Самый простой способ узнать место нахождения — вызвать команду ```git branch```. В обычной ситуации, когда мы находимся на последнем коммите, Git покажет такой вывод:

```bash
git branch

# Позже мы поговорим, что такое main
* main
```

Но если прямо сейчас загружен коммит из прошлого, то вывод станет таким:

```bash
* (HEAD detached at e6f625c)
  main
```

Такой способ проверки текущего местоположения требует постоянного внимания. Нужно не забывать его использовать. Конечно же, все забывают это делать, поэтому гораздо надежнее и удобнее вывести текущее местоположение прямо в командной строке. Например, так:

```bash
# Если на последнем коммите
my-git git:(main)

# Если на коммите из прошлого
my-git git:(e6f625c)
```

Именно так делают большинство профессиональных разработчиков. Как добиться такого вывода? Ответ на этот вопрос зависит от используемого командного интерпретатора:

[![asciinema](https://asciinema.org/a/5TrDddrSCdL0L7Ny5Ad21R5VA.png)](https://asciinema.org/a/5TrDddrSCdL0L7Ny5Ad21R5VA/iframe?cols=130&rows=25)

В Bash вывод местоположения происходит благодаря редактированию переменной окружения ```$PS1```, подробнее об этом вы можете почитать по ссылке в дополнительных материалах.

### Самостоятельная работа

1. Выполните все команды из урока
2. Настройте вывод текущего места в вашем терминале

### Дополнительные материалы

1. [Что такое PS1 и для чего используется?](https://ru.hexlet.io/blog/posts/kak-prisoedinitsya-k-rabote-nad-opensorsom-chto-takoe-ps1-i-drugie-voprosy-otvechaet-razrabotchik-heksleta-andrey-moshkov#chto-takoe-ps1-i-dlya-chego-ispolzuetsya)
2. [Именование коммитов](https://ru.hexlet.io/blog/posts/git-commit-message)
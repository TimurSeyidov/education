# Одиночка

> Также известен как: Singleton

## Суть паттерна

**Одиночка** — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

![Паттерн Одиночка](../images/patterns/05_01.png)

## Проблема

Одиночка решает сразу две проблемы, нарушая принцип единственной ответственности класса.

1. **Гарантирует наличие единственного экземпляра класса**. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.<br/>Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. В этом случае хотелось бы получить старый объект, вместо создания нового.<br/>Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает новый объект.<br/>
![Глобальный доступ к одному объекту](../images/patterns/05_02.png)
*Клиенты могут не подозревать, что работают с одним и тем же объектом.*
2. **Предоставляет глобальную точку доступа.** Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома. <br/>Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, который решает проблему №1, а также иметь к нему простой и доступный интерфейс.

Интересно, что в наше время паттерн стал настолько известен, что теперь люди называют «одиночками» даже те классы, которые решают лишь одну из проблем, перечисленных выше.

## Решение

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу. Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

## Аналогия из жизни

Правительство государства — хороший пример одиночки. В государстве может быть только одно официальное правительство. Вне зависимости от того, кто конкретно заседает в правительстве, оно имеет глобальную точку доступа «Правительство страны N».

## Структура

![Структура классов паттерна Одиночка](../images/patterns/05_03.png)

1. **Одиночка** определяет статический метод `getInstance`, который возвращает единственный экземпляр своего класса.<br/>Конструктор одиночки должен быть скрыт от клиентов. Вызов метода `getInstance` должен стать единственным способом получить объект этого класса.

## Псевдокод

В этом примере роль **Одиночки** отыгрывает класс подключения к базе данных.

Этот класс не имеет публичного конструктора, поэтому единственный способ получить его объект — это вызвать метод `getInstance`. Этот метод сохранит первый созданный объект и будет возвращать его при всех последующих вызовах.

```c
// Класс одиночки определяет статический метод `getInstance`,
// который позволяет клиентам повторно использовать одно и то же
// подключение к базе данных по всей программе.
class Database is
    // Поле для хранения объекта-одиночки должно быть объявлено
    // статичным.
    private static field instance: Database

    // Конструктор одиночки всегда должен оставаться приватным,
    // чтобы клиенты не могли самостоятельно создавать
    // экземпляры этого класса через оператор `new`.
    private constructor Database() is
        // Здесь может жить код инициализации подключения к
        // серверу баз данных.
        // ...

    // Основной статический метод одиночки служит альтернативой
    // конструктору и является точкой доступа к экземпляру этого
    // класса.
    public static method getInstance() is
        if (Database.instance == null) then
            acquireThreadLock() and then
                // На всякий случай ещё раз проверим, не был ли
                // объект создан другим потоком, пока текущий
                // ждал освобождения блокировки.
                if (Database.instance == null) then
                    Database.instance = new Database()
        return Database.instance

    // Наконец, любой класс одиночки должен иметь какую-то
    // полезную функциональность, которую клиенты будут
    // запускать через полученный объект одиночки.
    public method query(sql) is
        // Все запросы к базе данных будут проходить через этот
        // метод. Поэтому имеет смысл поместить сюда какую-то
        // логику кеширования.
        // ...

class Application is
    method main() is
        Database foo = Database.getInstance()
        foo.query("SELECT ...")
        // ...
        Database bar = Database.getInstance()
        bar.query("SELECT ...")
        // Переменная "bar" содержит тот же объект, что и
        // переменная "foo".
```

## Применимость

**Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий доступ к базе данных из разных частей программы).**

Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального метода. Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.

---

**Когда вам хочется иметь больше контроля над глобальными переменными.**

В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса, поэтому вы всегда уверены в наличии лишь одного объекта-одиночки.

Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек, поменяв код в одном месте (метод `getInstance`).

## Шаги реализации

1. Добавьте в класс приватное статическое поле, которое будет содержать одиночный объект.
2. Объявите статический создающий метод, который будет использоваться для получения одиночки.
3. Добавьте «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод одиночки.
4. Сделайте конструктор класса приватным.
5. В клиентском коде замените вызовы конструктора одиночка вызовами его создающего метода.

## Преимущества и недостатки

**Преимущества**

- Гарантирует наличие единственного экземпляра класса.
- Предоставляет к нему глобальную точку доступа.
- Реализует отложенную инициализацию объекта-одиночки.

**Недостатки**

- Нарушает [принцип единственной ответственности](single_responsibility_principle.md) класса.
- Маскирует плохой дизайн.
- Проблемы мультипоточности.
- Требует постоянного создания Mock-объектов при юнит-тестировании.

## Примеры

- **Сложность**: 1/3
- **Популярность**: 2/3
- **Применимость**: Многие программисты считают Одиночку антипаттерном, поэтому его всё реже и реже можно встретить в Python-коде.
- **Признаки применения паттерна**: Одиночку можно определить по статическому создающему методу, который возвращает один и тот же объект.

### Python

<tabs>
<tab title="Наивный Одиночка (небезопасный в многопоточной среде)">
<h4 id="simple_singleton">Наивный Одиночка (небезопасный в многопоточной среде)</h4>
<p>Топорно реализовать Одиночку очень просто — достаточно скрыть конструктор и предоставить статический создающий метод.</p>
<p>Тот же класс ведёт себя неправильно в многопоточной среде. Несколько потоков могут одновременно вызвать метод получения Одиночки и создать сразу несколько экземпляров объекта.</p>
<p><b>main.py</b>: Пример структуры паттерна</p>
<code-block lang="python">
<![CDATA[
class SingletonMeta(type):
    """
    В Python класс Одиночка можно реализовать по-разному. Возможные способы
    включают себя базовый класс, декоратор, метакласс. Мы воспользуемся
    метаклассом, поскольку он лучше всего подходит для этой цели.
    """

    _instances = {}

    def __call__(cls, *args, **kwargs):
        """
        Данная реализация не учитывает возможное изменение передаваемых
        аргументов в `__init__`.
        """
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]


class Singleton(metaclass=SingletonMeta):
    def some_business_logic(self):
        """
        Наконец, любой одиночка должен содержать некоторую бизнес-логику,
        которая может быть выполнена на его экземпляре.
        """
        # ...


if __name__ == "__main__":
    # Клиентский код.

    s1 = Singleton()
    s2 = Singleton()

    if id(s1) == id(s2):
        print("Singleton works, both variables contain the same instance.")
    else:
        print("Singleton failed, variables contain different instances.")

]]>
</code-block>
<p><b>Output.txt</b>: Результат выполнения</p>
<code-block lang="bash">
<![CDATA[
Singleton works, both variables contain the same instance.

]]>
</code-block>
</tab>
<tab title="Многопоточный Одиночка">
<h4 id="multitread_singleton">Многопоточный Одиночка</h4>
<p>Чтобы исправить проблему, требуется синхронизировать потоки при создании объекта-Одиночки.</p>
<p><b>main.py</b>: Пример структуры паттерна</p>
<code-block lang="python">
<![CDATA[
from threading import Lock, Thread


class SingletonMeta(type):
"""
Это потокобезопасная реализация класса Singleton.
"""

    _instances = {}

    _lock: Lock = Lock()
    """
    У нас теперь есть объект-блокировка для синхронизации потоков во время
    первого доступа к Одиночке.
    """

    def __call__(cls, *args, **kwargs):
        """
        Данная реализация не учитывает возможное изменение передаваемых
        аргументов в `__init__`.
        """
        # Теперь представьте, что программа была только-только запущена.
        # Объекта-одиночки ещё никто не создавал, поэтому несколько потоков
        # вполне могли одновременно пройти через предыдущее условие и достигнуть
        # блокировки. Самый быстрый поток поставит блокировку и двинется внутрь
        # секции, пока другие будут здесь его ожидать.
        with cls._lock:
            # Первый поток достигает этого условия и проходит внутрь, создавая
            # объект-одиночку. Как только этот поток покинет секцию и освободит
            # блокировку, следующий поток может снова установить блокировку и
            # зайти внутрь. Однако теперь экземпляр одиночки уже будет создан и
            # поток не сможет пройти через это условие, а значит новый объект не
            # будет создан.
            if cls not in cls._instances:
                instance = super().__call__(*args, **kwargs)
                cls._instances[cls] = instance
        return cls._instances[cls]


class Singleton(metaclass=SingletonMeta):
    value: str = None
    """
    Мы используем это поле, чтобы доказать, что наш Одиночка действительно
    работает.
    """

    def __init__(self, value: str) -> None:
        self.value = value

    def some_business_logic(self):
        """
        Наконец, любой одиночка должен содержать некоторую бизнес-логику,
        которая может быть выполнена на его экземпляре.
        """


def test_singleton(value: str) -> None:
    singleton = Singleton(value)
    print(singleton.value)


if __name__ == "__main__":
    # Клиентский код.

    print("If you see the same value, then singleton was reused (yay!)\n"
          "If you see different values, "
          "then 2 singletons were created (booo!!)\n\n"
          "RESULT:\n")

    process1 = Thread(target=test_singleton, args=("FOO",))
    process2 = Thread(target=test_singleton, args=("BAR",))
    process1.start()
    process2.start()

]]>
</code-block>
<p><b>Output.txt</b>: Результат выполнения</p>
<code-block lang="bash">
<![CDATA[
If you see the same value, then singleton was reused (yay!)
If you see different values, then 2 singletons were created (booo!!)

RESULT:

FOO
FOO

]]>
</code-block>
</tab>
</tabs>

### PHP

<tabs>
<tab title="Концептуальный пример">
<p>Этот пример показывает структуру паттерна <b>Одиночка</b>, а именно — из каких классов он состоит, какие роли эти классы выполняют и как они взаимодействуют друг с другом.</p>
<p>После ознакомления со структурой, вам будет легче воспринимать второй пример, который рассматривает реальный случай использования паттерна в мире PHP.</p>
<p><b>index.php</b>: Пример структуры паттерна</p>
<code-block lang="php">
<![CDATA[
namespace RefactoringGuru\Singleton\Conceptual;

/**
* Класс Одиночка предоставляет метод `GetInstance`, который ведёт себя как
* альтернативный конструктор и позволяет клиентам получать один и тот же
* экземпляр класса при каждом вызове.
*/ 

class Singleton
{
    /**
    * Объект одиночки храниться в статичном поле класса. Это поле — массив, так
    * как мы позволим нашему Одиночке иметь подклассы. Все элементы этого
    * массива будут экземплярами кокретных подклассов Одиночки. Не волнуйтесь,
    * мы вот-вот познакомимся с тем, как это работает.
    */
    private static $instances = [];

    /**
    * Конструктор Одиночки всегда должен быть скрытым, чтобы предотвратить
    * создание объекта через оператор new.
    */
    protected function __construct() { }

    /**
    * Одиночки не должны быть клонируемыми.
    */
    protected function __clone() { }

    /**
    * Одиночки не должны быть восстанавливаемыми из строк.
    */
    public function __wakeup()
    {
        throw new \Exception("Cannot unserialize a singleton.");
    }

    /**
    * Это статический метод, управляющий доступом к экземпляру одиночки. При
    * первом запуске, он создаёт экземпляр одиночки и помещает его в
    * статическое поле. При последующих запусках, он возвращает клиенту объект,
    * хранящийся в статическом поле.
    *
    * Эта реализация позволяет вам расширять класс Одиночки, сохраняя повсюду
    * только один экземпляр каждого подкласса.
    */
    public static function getInstance(): Singleton
    {
        $cls = static::class;
        if (!isset(self::$instances[$cls])) {
            self::$instances[$cls] = new static();
        }
        return self::$instances[$cls];
    }

    /**
    * Наконец, любой одиночка должен содержать некоторую бизнес-логику, которая
    * может быть выполнена на его экземпляре.
    */
    public function someBusinessLogic()
    {
        // ...
    }
}

/**
* Клиентский код.
*/
function clientCode()
{
    $s1 = Singleton::getInstance();
    $s2 = Singleton::getInstance();
    if ($s1 === $s2) {
        echo "Singleton works, both variables contain the same instance.";
    } else {
        echo "Singleton failed, variables contain different instances.";
    }
}

clientCode();

]]>
</code-block>
<p><b>Output.txt</b>: Результат выполнения</p>
<code-block lang="bash">
<![CDATA[
Singleton works, both variables contain the same instance.

]]>
</code-block>
</tab>
<tab title="Пример из реальной жизни">
<p>Паттерн <b>Одиночка</b> печально известен тем, что ограничивает повторное использование кода и усложняет модульное тестирование. Несмотря на это, он всё же очень полезен в некоторых случаях. В частности, он удобен, когда необходимо контролировать некоторые общие ресурсы. Например, глобальный объект логирования, который должен управлять доступом к файлу журнала. Еще один хороший пример: совместно используемое хранилище конфигурации среды выполнения.</p>
<p><b>index.php</b>: Пример из реальной жизни</p>
<code-block lang="php">
<![CDATA[
namespace RefactoringGuru\Singleton\RealWorld;

/**
* Если вам необходимо поддерживать в приложении несколько типов Одиночек, вы
* можете определить основные функции Одиночки в базовом классе, тогда как
* фактическую бизнес-логику (например, ведение журнала) перенести в подклассы.
*/ 

class Singleton
{
    /**
    * Реальный экземпляр одиночки почти всегда находится внутри статического
    * поля. В этом случае статическое поле является массивом, где каждый
    * подкласс Одиночки хранит свой собственный экземпляр.
    */
    private static $instances = [];

    /**
    * Конструктор Одиночки не должен быть публичным. Однако он не может быть
    * приватным, если мы хотим разрешить создание подклассов.
    */
    protected function __construct() { }

    /**
    * Клонирование и десериализация не разрешены для одиночек.
    */
    protected function __clone() { }

    public function __wakeup()
    {
        throw new \Exception("Cannot unserialize singleton");
    }

    /**
    * Метод, используемый для получения экземпляра Одиночки.
    */
    public static function getInstance()
    {
        $subclass = static::class;
        if (!isset(self::$instances[$subclass])) {
        // Обратите внимание, что здесь мы используем ключевое слово
        // "static"  вместо фактического имени класса. В этом контексте
        // ключевое слово "static" означает «имя текущего класса». Эта
        // особенность важна, потому что, когда метод вызывается в
        // подклассе, мы хотим, чтобы экземпляр этого подкласса был создан
        // здесь.
            self::$instances[$subclass] = new static();
        }
        return self::$instances[$subclass];
    }
}

/**
* Класс ведения журнала является наиболее известным и похвальным использованием
* паттерна Одиночка.
*/ 

class Logger extends Singleton
{
    /**
    * Ресурс указателя файла файла журнала.
    */
    private $fileHandle;

    /**
    * Поскольку конструктор Одиночки вызывается только один раз, постоянно
    * открыт всего лишь один файловый ресурс.
    *
    * Обратите внимание, что для простоты мы открываем здесь консольный поток
    * вместо фактического файла.
    */
    protected function __construct()
    {
        $this->fileHandle = fopen('php://stdout', 'w');
    }

    /**
    * Пишем запись в журнале в открытый файловый ресурс.
    */
    public function writeLog(string $message): void
    {
        $date = date('Y-m-d');
        fwrite($this->fileHandle, "$date: $message\n");
    }

    /**
    * Просто удобный ярлык для уменьшения объёма кода, необходимого для
    * регистрации сообщений из клиентского кода.
    */
    public static function log(string $message): void
    {
        $logger = static::getInstance();
        $logger->writeLog($message);
    }
}

/**
* Применение паттерна Одиночка в хранилище настроек – тоже обычная практика.
* Часто требуется получить доступ к настройкам приложений из самых разных мест
* программы. Одиночка предоставляет это удобство.
*/

class Config extends Singleton
{
    private $hashmap = [];

    public function getValue(string $key): string
    {
        return $this->hashmap[$key];
    }

    public function setValue(string $key, string $value): void
    {
        $this->hashmap[$key] = $value;
    }
}

/**
* Клиентский код.
*/
Logger::log("Started!");

// Сравниваем значения одиночки-Логгера.
$l1 = Logger::getInstance();
$l2 = Logger::getInstance();
if ($l1 === $l2) {
    Logger::log("Logger has a single instance.");
} else {
    Logger::log("Loggers are different.");
}

// Проверяем, как одиночка-Конфигурация сохраняет данные...
$config1 = Config::getInstance();
$login = "test_login";
$password = "test_password";
$config1->setValue("login", $login);
$config1->setValue("password", $password);
// ...и восстанавливает их.
$config2 = Config::getInstance();
if ($login == $config2->getValue("login") &&
    $password == $config2->getValue("password")
) {
    Logger::log("Config singleton also works fine.");
}

Logger::log("Finished!");

]]>
</code-block>
<p><b>Output.txt</b>: Результат выполнения</p>
<code-block lang="bash">
<![CDATA[
2018-06-04: Started!
2018-06-04: Logger has a single instance.
2018-06-04: Config singleton also works fine.
2018-06-04: Finished!

]]>
</code-block>
</tab>
</tabs>
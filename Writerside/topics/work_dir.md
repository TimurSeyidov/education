# Рабочая директория

После клонирования репозитория *my-git* мы можем увидеть внутри него директорию *.git* и добавленные нами файлы. Посмотрим, что произойдет, если удалить один из файлов:

```bash
rm PEOPLE.md
git status

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
    deleted:    PEOPLE.md

no changes added to commit (use "git add" and/or "git commit -a")
```

Git сообщает, что файл был удален, и предлагает команды для восстановления или коммита изменений. Здесь стоит остановиться и немного погрузиться в то, как работает git. Откуда он вообще знает, что файл был удален? Ответ на этот вопрос вы узнаете в этом уроке.

## Как узнать статус репозитория

Внутри директории проекта мы видим файлы проекта с одной стороны и директорию *.git* с другой.

Репозиторием является именно директория *.git*. Она хранит всю информацию о том, какие были изменения, а также сами изменения.

А вот все, что находится снаружи, это так называемая **рабочая директория** (*working directory*). Эти файлы извлекаются из *.git* в момент клонирования.

Каждый раз, когда мы производим изменения в рабочей директории, Git сравнивает измененные файлы с файлами внутри *.git*, то есть их состоянием на момент последнего коммита. Если есть изменения относительно последней зафиксированной версии, то Git сообщает нам об этом в выводе команды ```git status```.

В этом очень легко убедиться, если последовать совету Git в выводе выше и восстановить удаленный файл:

```bash
git restore PEOPLE.md
git status

On branch main
Your branch is up to date with 'origin/main'.

nothing to commit, working tree clean

# Сам файл вернулся таким, каким он был на момент последнего коммита
```

Можно удалить все файлы в рабочей директории и потом без проблем их восстановить. Так мы достигаем важной цели — создаем возможность быстро восстановить последнюю версию кода, если внесенные изменения нас больше не устраивают.

Еще мы можем закоммитить их, если это нужно:

```bash
rm PEOPLE.md
# Любое изменение нужно добавлять в индекс
git add PEOPLE.md
git commit -m 'remove PEOPLE.md'

[main e15afd2] remove PEOPLE.md
1 file changed, 1 deletion(-)
delete mode 100644 PEOPLE.md
# Теперь этот файл пропал из рабочей директории
```

Обратите внимание на важную деталь. Независимо от того, удаляем мы файл, добавляем или меняем, процедура выполнения коммита не меняется. После изменений всегда делается ```git add```, который подготавливает изменение к коммиту (а не добавляет файл). После этого выполняется коммит.

Кстати, у Git есть команда ```git rm```, которая объединяет в себе удаление и подготовку к коммиту:

```bash
git rm PEOPLE.md
# Равносильно rm + git add
```
[![asciicinema](https://asciinema.org/a/TQc8FcLAJ2fYppb2YeJniT1Eh.png)](https://asciinema.org/a/TQc8FcLAJ2fYppb2YeJniT1Eh/iframe?cols=130)

### Самостоятельная работа

1. Выполните все шаги из урока
2. Удалите файл *NEW.md* и сделайте коммит
3. Добавьте файл *INFO.md* с текстом *git is awesome!* и сделайте коммит
4. Залейте изменения на GitHub с помощью ```git push```
5. Обновите страницу репозитория на GitHub и изучите произошедшие изменения

# True и false, break и continue

## Логический тип данных

Если `a` и `b` — числа (допустим, действительные), то у выражения `a + b` есть какое-то значение (зависящее от значений `a` и `b`) и тип — тоже действительное число. Как вы думаете, можно ли сказать, что у выражения `a == b` есть значение и тип? Или это просто конструкция, которая всегда должна стоять в условии `if` или `while`?

На самом деле такое выражение имеет и тип под названием `bool`, и значение: `True` (истина) или `False` (ложь). По-русски `bool` — это булев тип, или булево значение (в честь математика Джорджа Буля), иногда его еще называют логический тип.
Логический тип может иметь только два значения, а над переменными логического типа можно выполнять логические операции `not`, `and`, `or`.

Также для приведения к логическому типу можно использовать функцию `bool`, которая для ненулевого значения вернет истину.

```python
k = True
print(k) # выведет True
print(not k) # выведет False
k = 5 > 2
print(k) # выведет True
k = bool(0)
print(k) # выведет False
k = bool("")
print(k) # выведет False
k = bool(13)
print(k) # выведет True, т.к. число не 0
k = bool("q")
print(k) # выведет True, т.к. строка не пустая
k = bool("False")
print(k) # выведет True, т.к. строка не пустая
```

Или вот еще пример:
```python
if True:
    print('Эта строка будет выведена на экран.')
else:
    print('Эта строка никогда не будет выведена на экран.')
    print(2 * 2 == 4)  # выведет True
a = input()
b = input()
# Теперь переменная equal равна True, если строки a и b равны,и False
# в противном случае
equal = (a == b)
if equal and len(a) < 6:
    print('Вы ввели два коротких одинаковых слова.')
```

## Использование флагов

Обычно переменные с булевым значением используются в качестве флагов.
Изначально флаг устанавливается в `False`, потом программа как-то работает, а при наступлении определенного события флаг устанавливается в `True`. После идет проверка, поднят ли флаг. В зависимости от ее результата выполняется то или иное действие. Иными словами, флаг — это переменная с булевым значением, которая показывает, наступило ли некое событие.

В программе имеется флаг `said_forbidden_word`, который означает «сказал ли пользователь запретное слово „синхрофазотрон“». Флаг равен `True`, если сказал, и `False`, если нет.
В самом начале пользователь еще ничего не успел сказать, поэтому флаг установлен в `False`. Далее на каждой итерации цикла, если пользователь сказал запретное слово, флаг устанавливается в `True` и остается в таком состоянии (при необходимости флаг можно и «опустить»). Как только флаг оказывается равен `True`, поведение программы меняется: перед каждым вводом выдается предупреждение, а в конце выдается другое сообщение.

Переменным-флагам особенно важно давать осмысленные имена (обычно — утверждения вроде `said_forbidden_word`, `found_value`, `mission_accomplished`, `mission_failed`), ведь флагов в программе бывает много.
Стоит пресекать попытки подобно `if found == True`. Это демонстрирует непонимание того, что любое условие обычного вида «что-то == чему-то» само по себе равняется либо `True`, либо `False`, и дополнительное сравнение избыточно. Решать эти задачи вообще без использования флагов — нормально и допустимо.

## Операторы break и continue. Бесконечные циклы

Если нужно прекратить работу цикла, как только случится некое событие, то, кроме флага, есть и другой способ — оператор разрыва цикла `break` (он работает и для цикла `for`). Это не функция и не заголовок блока, а оператор, который состоит из одного слова. Он немедленно прерывает выполнение цикла `for` или `while`.

```python
for i in range(10):
	print('Итерация номер', i, 'начинается...')
	if i == 3:
        print('Ха! Внезапный выход из цикла!')
        break
	print('Итерация номер', i, 'успешно завершена.')
print('Цикл завершён.')
```

```python
while True:
    word = input()
    if word == 'стоп':
        break
    print('Вы ввели:', word)
print('Конец.')
```

Впрочем злоупотреблять этой конструкцией и вообще оператором `break` не стоит. Когда программист читает ваш код, он обычно предполагает, что после окончания цикла `while` условие в заголовке этого цикла ложно. Если же из цикла можно выйти по команде `break`, то это уже не так. Логика кода становится менее ясной.

Оператор `continue` немедленно завершает текущую итерацию цикла и переходит к следующей.

```python
for i in range(10):
    print('Итерация номер', i, 'начинается...')
    if i == 3:
        print('...но её окончание таинственно пропадает.')
        continue
    print('Итерация номер', i, 'успешно завершена.')
print('Цикл завершён.')
```

Часто использовать `break` и `continue` не рекомендуют, поскольку они приводят к произвольному перемещению точки выполнения программы по всему коду, что усложняет понимание и следование логике. Тем не менее разумное использование этих операторов может улучшить читабельность циклов в программе, уменьшив при этом количество вложенных блоков и необходимость в сложной логике выполнения цикла.
Выход из цикла с помощью оператора break не является штатным завершением цикла, поэтому `else`-часть в этом случае не выполнится
















